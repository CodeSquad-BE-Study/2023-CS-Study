HTTP는 웹상에서 클라이언트와 서버 간 통신을 위한 프로토콜입니다. HTTP는 어플리케이션 레이어에 존재하는 프토콜이고, 인터넷을 통해 통신을 위해 전송 계층에 존재하는 프토토콜을 사용해야합니다.

HTTP 같은 경우 신뢰성 있는 통신만 가능하다면, 어떠한 전송 프로토콜을 사용해도 상관없습니다.

즉 UDP도 신뢰성을 보장받을 수 있다면 사용 가능하다는 이야기

## HTTP 1.0 : TCP 연결 → 하나의 요청 → 하나의 응답 → TCP 연결 종료

- 매번 새로운 연결로 인한 비효율성

---

## HTTP 1.1 : TCP 연결 → 다수의 요청 → 다수의 응답→ TCP 연결 종료

- 한번의 연결로 다수의 요청 및 응답 보낼 수 있도록 수정 (Persistent Connection)
- HTTP pipelining을 통해 응답을 받지 않고, 다른 요청을 보내는 기법 (이때 TCP의 pipelining과는 다른 개념이다)

## HTTP 1.1의 단점

pipelining을 통해 다수의 요청을 한번에 보낼 수 있지만, 이로 인해 Head of Line Blocking과 HTTP 헤더의 중복과 같은 문제가 발생한다.

### Head of line Blocking

서버는 다수의 HTTP 요청에 대해 순차적으로 응답을 한다.
이때, 하나의 응답이 지연될 경우, 이후의 응답도 함께 지연되는 문제

### Header 구조의 중복

하나의 연결에서 다수의 요청을 보낼 때, HTTP 헤더 부분에서 많은 중복이 발생한다.

---

## HTTP 2 : TCP 연결 → 하나의 요청 스트림 → 하나의 응답 스트림 → TCP 연결 종료

- 기존 HTTP/1.X 버전의 성능 향상에 초점을 맞춘 프로토콜
- 표준의 대체가 아닌 확장

### HTTP 메시지 전송 방식의 변화

1. 바이너리 프레이밍 계층 사용
- 파싱 및 전송 속도 증가
- 오류 발생 가능성 낮아짐

→ 요청 및 응답을 각각 스트림을 통해 보내는 방식으로 변경 (Request and response multiplexing)

→ 이로인해, 순차적으로 응답하는 형식이 아닌, 병렬적으로 응답하는 형식으로 변경하여, HOL 을 해결

```json
HTTP/2는 어플리케이션 레이어 수준의 Head of line Blocking은 해결할 수 있었다.
TCP 수준의 Head of line Blocking은 해결하지 못했다.
TCP 세그먼트 손실이 일어날 때의 문제를 생각해 보자. 
```

1. Stream Prioritization
- 리소스간 우선 순위를 설정 가능
1. Server push
- 요청 받지 않는 리소스를 서버가 클라이언트한테 push 가능 (연관된 리소스를 함께 전송)
1. Header Compression
- 헤더의 크기를 줄여 페이지 로드 시간 감소 (중복된 헤드 필드는 보내지 않음)

---

## QUIC

UDP 기반의 프로토콜

UDP 프로토콜 위에서 신뢰성을 보장할 수 있도록 커스텀마이징을 한 프로토콜이 QUIC 프로토콜이다.

Connection UUID라는 고유한 식별자로 서버와 연결 (IP/port 로 식별자를 구별하는 기존의 프로토콜과 다른 방식)
